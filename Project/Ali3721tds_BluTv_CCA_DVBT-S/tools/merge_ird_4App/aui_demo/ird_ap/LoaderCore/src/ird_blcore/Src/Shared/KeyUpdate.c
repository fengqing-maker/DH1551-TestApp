/*****************************************************************************
*                  COPYRIGHT (C) 2011 IRDETO B.V.                            *
******************************************************************************
*          File : KeyUpdate.c                                                *
*                                                                            *
*   Description : This takes and RSA encrypted message encrypted under a     *
*                 1024 bit key, and extracts the new 640 bit code download   *
*                 and mux verifier key.  A message version number is used to *
*                 avoid re-using a previously used message, as the process   *
*                 is time consuming.                                         *
*                                                                            *
*****************************************************************************/

#include "LoaderCorePrivate.h"


/* Safe key size for RSA operation */
#define RSA_SMALLEST_KEY_SIZE    (((2 * 0xff + 2) + (0xff + 2)))
#define SAFE_KEY_SIZE   ( (RSA_SMALLEST_KEY_SIZE > SIZE_PUBKEY)? RSA_SMALLEST_KEY_SIZE : SIZE_PUBKEY )

#if (RSA_SMALLEST_KEY_SIZE < SIZE_PUBKEY)
    #error "RSA_SMALLEST_KEY_SIZE can not be smaller than SIZE_PUBKEY"
#endif



#ifdef USEDEVELOPMENTMASTERKEY
static const lc_uchar abMasterKey [] =
{
	//public moudules as below:
	0xE7,0x39,0x5A,0xA5,0x5B,0xD2,0x2D,0xAB,0x26,0x28,0x26,0x45,0x31,0x02,0xE6,0xBD,
	0x45,0x34,0x95,0x2A,0x7F,0xA2,0xA0,0x86,0xA3,0xD7,0x25,0x6F,0xF9,0x67,0x2A,0x38,
	0x10,0x59,0x7E,0x54,0x25,0x31,0x11,0x2E,0x42,0x45,0x26,0x38,0xDE,0x72,0x67,0x5D,
	0xDA,0x5B,0x18,0x20,0x13,0xBC,0xE1,0x7C,0x9E,0x2F,0xC3,0xF1,0x37,0x66,0xDF,0xD8,
	0xAD,0xBB,0x5B,0x52,0x3C,0xCB,0x3E,0x80,0x4A,0x45,0xE4,0xC4,0xCC,0x41,0xD9,0xFE,
	0x8F,0xF2,0xFD,0xC4,0x86,0x9F,0xCE,0x02,0x24,0x3A,0x1F,0x89,0x78,0xFF,0x1E,0x97,
	0x28,0x06,0xF8,0xA6,0x26,0x61,0x8A,0x22,0x86,0xC2,0xB0,0xA9,0xBD,0x9E,0xAA,0x6A,
	0x68,0x3E,0x3D,0x82,0x6D,0x1F,0x9C,0x8D,0xD3,0x7A,0xEC,0xE1,0x1F,0xF2,0xDB,0xF3,
	0x3F,0xDF,0xFF,0x09,0x07,0x28,0x16,0x53,0x9B,0xB7,0x98,0xA9,0x6D,0xED,0xB1,0x8E,
	0x2D,0x50,0x01,0x4C,0x88,0xCB,0xE4,0x4C,0xA3,0xC4,0xAE,0x8B,0x67,0x16,0x6B,0x31,
	0x2B,0xFD,0x0E,0xDF,0x3C,0xA6,0x15,0x1D,0x7C,0x6E,0x6D,0x01,0x65,0x54,0xB8,0x86,
	0xEB,0x3D,0xFC,0x6E,0x54,0xFE,0x31,0xA3,0xD8,0x59,0x27,0x53,0x65,0xA3,0xE1,0x3B,
	0xFF,0x38,0xAE,0xED,0x8E,0x85,0x00,0xCD,0xBE,0x57,0xA0,0x6D,0xD8,0xE9,0xBE,0xB5,
	0x13,0x50,0x36,0x84,0x63,0x58,0xE7,0x9E,0xF4,0x61,0x34,0x71,0x92,0x81,0xF4,0xFB,
	0x01,0xD6,0xD4,0xDB,0x5E,0xCB,0x1A,0x39,0x06,0x80,0xE3,0xAA,0xC3,0xF6,0xFA,0x8D,
	0x44,0xAC,0xC7,0x85,0x7F,0xD3,0x5E,0xC9,0xB8,0x07,0x5E,0xCE,0x57,0x17,0x56,0xCB,
	//authentication message
	0x3A,0xA8,0x89,0x7C,0xEA,0x4A,0x0D,0xA5,0x1E,0x97,0x78,0x8A,0x99,0x88,0x5E,0x76,
	0x97,0x59,0xBF,0x77,0x2B,0x90,0xDB,0xAC,0x23,0x30,0x98,0x20,0x7C,0x2C,0x10,0x03,
	0x24,0x3A,0xD5,0xA6,0xAA,0xD3,0x4F,0x19,0x0B,0xF2,0x56,0x35,0x10,0xF4,0x11,0x0F,
	0xD9,0xA2,0x1B,0xE1,0x43,0xAF,0x65,0x96,0x41,0x24,0xD2,0x4D,0xEC,0x1B,0x52,0x48,
	0x74,0x5E,0x21,0xD3,0xFD,0x06,0xDB,0xA9,0x7B,0x0B,0xD6,0x33,0x87,0x36,0x9D,0x05,
	0x4C,0xC2,0xBF,0x57,0x04,0x00,0x5B,0x50,0x4F,0xF1,0x5A,0x61,0x9A,0x4F,0x9C,0x90,
	0x73,0xD8,0x96,0x08,0x76,0x64,0x71,0xB1,0x5E,0x1F,0x04,0x33,0x0F,0x7D,0xD5,0x06,
	0xDA,0xC2,0xF5,0x9D,0x52,0xB8,0x15,0xE4,0x5F,0x44,0xD6,0xB1,0xBF,0xCA,0x04,0x33,
	0xD3,0xD3,0x97,0x94,0x72,0xCB,0xB5,0xCA,0xE3,0x69,0xD5,0x87,0xC5,0x45,0x16,0x5E,
	0xFB,0x60,0xEE,0x50,0x8A,0x1E,0x29,0xED,0x3B,0x0E,0x21,0x0B,0x8A,0x22,0x87,0x3A,
	0x56,0x5E,0xA3,0x67,0xA7,0xE2,0xC2,0x7B,0xFD,0x07,0xC0,0xC4,0x68,0x41,0x6C,0x3C,
	0x7B,0xB4,0xA0,0xB9,0xD8,0xB0,0x38,0xC1,0x01,0x37,0xEC,0x50,0xDD,0x5C,0x30,0xC0,
	0xFE,0x7E,0xE4,0x23,0x89,0x5B,0x0D,0xF5,0x43,0x5A,0x95,0x10,0x1D,0xC8,0x2E,0xBD,
	0xA2,0x25,0x69,0xE5,0x85,0x0C,0xF7,0x11,0x5F,0xE9,0xDA,0xB9,0xD5,0xBC,0xE9,0xAF,
	0x0D,0xAE,0x30,0x67,0x77,0x6D,0xD4,0xB1,0x57,0x5B,0x0B,0xC4,0x50,0xC9,0xD5,0xF0,
	0x84,0x0F,0x91,0xF0,0xAD,0x5B,0x01,0x9F,0x86,0x26,0xE6,0x75,0xFE,0xAC,0xD9,0xA6
};
#else

static const lc_uchar abMasterKey [] =
{
	//public moudules as below:
	0xD0,0xB3,0x14,0xC4,0x1E,0xEC,0xF5,0x10,0xE2,0x80,0x3D,0x6E,0xA4,0x67,0x3E,0xD4,
	0x00,0xF2,0x4C,0x00,0x37,0x0E,0x8F,0x91,0x63,0x19,0x07,0x47,0x16,0x8D,0x7A,0x83,
	0x48,0x39,0xC7,0x3E,0xFA,0x0C,0x3B,0xAC,0x25,0x9C,0x99,0x47,0x94,0x9C,0x08,0xF4,
	0x2C,0xFB,0xE8,0xF7,0xF3,0x23,0xF3,0x3C,0x81,0x08,0xEE,0x99,0x38,0x49,0xF1,0x9C,
	0x8D,0x2A,0x78,0x29,0x01,0xDE,0x09,0xFC,0x28,0x6B,0xB2,0xE4,0x5D,0xC1,0x56,0x33,
	0x99,0x72,0x76,0xDB,0x50,0x6A,0x83,0x51,0x95,0x49,0x40,0xE8,0xD1,0x6E,0xD9,0xFF,
	0xEF,0xEC,0x11,0x4B,0x7D,0x3E,0x60,0x6C,0xFB,0xFD,0xC0,0x92,0x9F,0xFB,0x66,0x78,
	0x91,0x61,0x45,0xE6,0xE5,0x7E,0x45,0x19,0xEA,0x69,0xE0,0xAC,0x1D,0x15,0xA8,0xAE,
	0x9F,0x9F,0xB4,0x43,0xE1,0x6E,0x94,0x4E,0x52,0x8C,0xCC,0xD0,0x18,0x8A,0x0F,0x4A,
	0x05,0xBA,0x99,0xA2,0x57,0x68,0xA1,0x62,0x23,0xE4,0x82,0x27,0x8A,0x09,0x1D,0x63,
	0xAE,0xCF,0xB2,0xDE,0xE1,0x17,0x39,0x73,0xD1,0x42,0x69,0xAA,0xF1,0x51,0x74,0x59,
	0x77,0xF8,0xFC,0xB2,0x42,0x36,0xF5,0x0E,0x58,0xDD,0x58,0x26,0xDC,0x6B,0x26,0xB1,
	0x8E,0x69,0xE6,0x1A,0x46,0x06,0x6B,0x48,0xEC,0xEF,0xAB,0xDD,0x9E,0x94,0x98,0x74,
	0x7E,0xE6,0x80,0x7E,0xAF,0xAB,0x4D,0x81,0xE6,0x3A,0xDF,0xB3,0x78,0xE3,0x26,0xB4,
	0xB5,0xDE,0x50,0x20,0x13,0x43,0x39,0x32,0x9F,0xAD,0xD8,0xBB,0x3F,0x31,0x2B,0x40,
	0x04,0x8E,0x4F,0xE0,0x49,0x53,0xDF,0xE2,0x99,0x10,0xB1,0xC9,0xD9,0xCC,0xF5,0xFB,
	//authentication message
	0x35,0x54,0xF0,0x3A,0xDB,0xF7,0xF0,0xC9,0x7F,0x07,0xEC,0x75,0x21,0x3B,0xCA,0xE4,
	0x7B,0xC0,0x3B,0x7E,0x7D,0x9A,0xED,0x6A,0xBF,0x27,0xDA,0xA4,0xED,0xBF,0x71,0x76,
	0xB8,0x51,0xCC,0x30,0x04,0xF3,0x7E,0x3B,0x8C,0x3F,0xBD,0x2C,0x0B,0xAC,0x87,0xFC,
	0x1E,0xF6,0x50,0xC3,0xCF,0xFB,0xB2,0xB0,0xD2,0xFF,0xC2,0xE4,0x5B,0x93,0x8C,0x3C,
	0x84,0xB7,0xE9,0xCC,0xF8,0x5B,0xAE,0x97,0x3B,0xB8,0x4D,0x52,0xE7,0x2A,0x55,0xC8,
	0x32,0x3A,0xB6,0xAF,0x77,0x54,0xA9,0xCA,0x0E,0xAE,0x32,0x8A,0x3C,0xAF,0x27,0x1F,
	0x45,0x5D,0x14,0x67,0x2E,0x9A,0x6C,0x86,0x41,0x7D,0xF6,0xFB,0xD0,0xFD,0xD2,0xA7,
	0x43,0x68,0x4E,0xC8,0x3F,0x82,0xC2,0x30,0x62,0x3B,0x1A,0x3E,0x2A,0xA0,0x3C,0x55,
	0x81,0xAE,0xF5,0xA0,0x3C,0x5F,0xCC,0x61,0x9E,0x03,0x22,0x14,0x34,0x4B,0x17,0x63,
	0xE7,0x01,0x3B,0xB8,0x0F,0x76,0x60,0x17,0xAE,0xEB,0x48,0xD8,0xC9,0x8A,0x4B,0x24,
	0x46,0x97,0xC0,0x0B,0x82,0xA4,0x1D,0xE6,0x1E,0x08,0x11,0xC8,0x03,0x37,0xCF,0x86,
	0x4B,0x26,0x2F,0xEE,0x05,0x7F,0x8F,0x16,0xE6,0x1C,0xA1,0x15,0xF5,0x60,0x8A,0x42,
	0x64,0x72,0x8D,0x87,0xFC,0x4B,0x42,0x64,0xCC,0x84,0x53,0x6A,0xC4,0x71,0x6A,0xF9,
	0x1A,0x9E,0xE1,0xD2,0xD5,0xE0,0x3D,0x1C,0xDC,0xE0,0x30,0xB8,0x46,0xF9,0xCF,0x2E,
	0x1E,0x61,0x52,0x46,0x90,0xE7,0x8F,0xD1,0xD5,0xDC,0x72,0xEC,0x62,0xA3,0x19,0x7C,
	0x7F,0x30,0x01,0xAD,0xDD,0x60,0xF4,0x6F,0xE2,0xE6,0x8D,0xAE,0xF7,0x75,0x9F,0x9C
};

#endif

const lc_uchar loaderEnhancedSecureKey[]= 
{ 
	0xB0,0xF0,0x75,0xB6,0xC5,0xC2,0xF7,0x59,0x4D,0x87,0x9A,0xC9,0x56,0x14,0x8A,0xE7,
	0x73,0x44,0x79,0xC9,0xDF,0x27,0x6D,0x26,0xEA,0x0F,0xCE,0x38,0x82,0xED,0xE9,0xA6,
	0xA7,0x9E,0xDD,0x0A,0xC2,0x0B,0x95,0xE7,0x3E,0x3E,0x86,0x92,0x1F,0x19,0x97,0x20,
	0x5E,0x84,0x29,0x2C,0x75,0xED,0x41,0x81,0xFA,0xCB,0xFD,0x0D,0x10,0x4F,0xE1,0xAE,
	0x76,0x32,0xB6,0x21,0xB1,0x6F,0xF6,0xA1,0x1A,0xFC,0xBA,0x91,0xDF,0xF4,0xDC,0xE7,
	0xD3,0x81,0xFE,0x17,0x6D,0x77,0xEB,0x99,0x85,0x7D,0xD5,0x8C,0xBE,0x4D,0xB9,0xB3,
	0x50,0xF5,0x8F,0xE7,0xAD,0x52,0xF1,0x9D,0xB2,0xF8,0x2B,0x12,0xC9,0xB6,0xB8,0xE2,
	0xC8,0x65,0xBD,0x77,0x32,0x3D,0x6F,0x98,0xA1,0x7C,0x27,0xA6,0xD7,0x3F,0x0A,0xC1,
	0x44,0xE6,0x0E,0x3B,0x6E,0x33,0x9F,0x43,0xD5,0xE9,0x92,0x47,0x1D,0x7F,0x5D,0x3A,
	0x66,0x59,0xA7,0x09,0xDA,0x6D,0x51,0x8A,0x80,0xC2,0xAF,0x07,0xBA,0x0D,0x5C,0x77,
	0xD8,0x29,0x2D,0x1E,0x21,0x14,0xC4,0x02,0xC2,0x48,0x5E,0x11,0x9B,0x18,0xE5,0x7F,
	0x8D,0x03,0x0D,0xD7,0x07,0xA7,0x36,0x23,0xD3,0x06,0x76,0x97,0xE2,0x0D,0x00,0xAA,
	0x8F,0xB9,0x49,0x74,0x58,0x87,0xA8,0x7B,0x53,0xDA,0x39,0xAE,0xA3,0x60,0x17,0xDF,
	0x9A,0xAD,0x2E,0xBF,0x54,0x12,0x82,0x5B,0x22,0x34,0x7B,0x73,0x07,0x94,0x4A,0xF0,
	0x20,0x53,0xB3,0xF4,0xA4,0xDF,0x7C,0x77,0x92,0x32,0x2A,0x09,0xFE,0xF2,0x99,0xBB,
	0x0D,0x7D,0x03,0x77,0x51,0xDE,0x1E,0x87,0xC8,0x26,0x40,0xA5,0x4F,0x23,0x12,0xEB 
};

static const lc_uchar fixedManKeyUpgradeInfo[] = {0xFF, 0xFF, 0x00, 0x00};
static const lc_uchar fixedCustomerKeyUpgradeInfo[] = {0x00, 0x00, 0x00, 0x01};

static lc_bool CheckKeyMsg (const lc_uchar pabRsaKey[SIZE_PUBKEY], const lc_buffer_st *pMessage, const lc_uchar pabRsaKeyAuthMsg[SIZE_PUBKEY])
{

	lc_bool keyLegal = LC_TRUE;
	lc_uchar hashData[SHA256_HASH_SIZE] = {0};
	lc_buffer_st mHash = {LC_NULL, 0};
	mHash.bytes = hashData;
	mHash.length = SHA256_HASH_SIZE;
	
	if(CRYPT_OK != sha256_hash(pMessage, hashData))
	{
		keyLegal = LC_FALSE;
	}

	if(LC_TRUE == keyLegal && PKCS_ERROR_SUCCESS !=  Rsa_VerifyPkcs((lc_uchar*)pabRsaKey, (lc_uchar*)pabRsaKeyAuthMsg, &mHash))
	{
		keyLegal = LC_FALSE;
	}

	return keyLegal;
	
}

static lc_result UkCheckValid(const lc_key_update_message *pUkData)
{
	lc_result result = LC_SUCCESS;

	if ((LC_memcmp(pUkData->loaderRealInfoControl, pUkData->loaderUpgradeInfoControl, SIZE_LODER_INFO_CONTROL) == 0)
		&& ((LC_memcmp(fixedManKeyUpgradeInfo, pUkData->loaderUpgradeInfoControl, SIZE_LODER_INFO_CONTROL) == 0)
		|| (LC_memcmp(fixedCustomerKeyUpgradeInfo, pUkData->loaderUpgradeInfoControl, SIZE_LODER_INFO_CONTROL) == 0)))
	{
		result = LC_FAILURE;
	}

	if (LC_SUCCESS == result)
	{
		lc_uchar pMsk[SIZE_PUBKEY]= {0};
		lc_buffer_st pMessage = {LC_NULL, 0};
		lc_uchar pUKMsg[SIZE_LODER_INFO_CONTROL *2 + SIZE_LODER_RESERVED_INFO_CONTROL+ SIZE_PUBKEY]= {0};

		lc_uchar *pTempUKMsg = pUKMsg;
		pMessage.bytes = pUKMsg;
		pMessage.length = SIZE_LODER_INFO_CONTROL*2 + SIZE_LODER_RESERVED_INFO_CONTROL + SIZE_PUBKEY;

		LC_memcpy(pMsk, abMasterKey, SIZE_PUBKEY);

		LC_memcpy(pTempUKMsg, pUkData->loaderRealInfoControl, SIZE_LODER_INFO_CONTROL);
		pTempUKMsg = pTempUKMsg + SIZE_LODER_INFO_CONTROL;

		LC_memcpy(pTempUKMsg , pUkData->loaderUpgradeInfoControl, SIZE_LODER_INFO_CONTROL);
		pTempUKMsg = pTempUKMsg + SIZE_LODER_INFO_CONTROL;

		LC_memcpy(pTempUKMsg, pUkData->loaderReservedInfoControl, SIZE_LODER_RESERVED_INFO_CONTROL);
		pTempUKMsg = pTempUKMsg + SIZE_LODER_RESERVED_INFO_CONTROL;

		LC_memcpy(pTempUKMsg, pUkData->loaderPubKey, SIZE_PUBKEY);

		if( CheckKeyMsg(pMsk, &pMessage, pUkData->loaderPubKeyAuthMsg) == LC_FALSE)
		{
			result = LC_FAILURE;
		}
	}

	return result;

}

/*****************************************************************************
*                                                                            *
*       ROUTINE : DecryptUK                                        *
*                                                                            *
*   DESCRIPTION : This routine authenticates a message using the MasterKey   *
*                 embedded in the loader image.                              *
*                                                                            *
*         INPUT : pabMsg - the message to authenticate                       *
*                                                                            *
*       RETURNS : LC_TRUE if message is authenticated, else LC_FALSE.              *
*                                                                            *
*        Author : Jacobus Ellis                                              *
*                                                                            *
*  Last Changed : 23 Jan 1998 - RLS                                          *
*                 Modified for PC Card loader.                               *
*                 13 Jan 2005 - JE                                           *
*                 Modified for IP/Module loader core.                        *
*                                                                            *
*****************************************************************************/
static lc_result DecryptUK (
    lc_key_update_message* pabAuthed, 
    const lc_uchar* pabMsg, 
    lc_uint32 abMsgLength)
{

	lc_result result = LC_SUCCESS;
	lc_uchar *psMsgRsaOperate = LC_NULL;
	lc_key_update_message *pMsgParsed = LC_NULL;

	if (LC_NULL == pabMsg ||
		abMsgLength < SIZE_UK_DATA)
	{
		result = LC_ERROR_INVALID_PARAMETER;
	}

	if (LC_SUCCESS == result)
	{
		pMsgParsed = LC_MALLOC(sizeof(lc_key_update_message));
		if (LC_NULL == pMsgParsed)
		{
			result = LC_ERROR_INSUFFICIENT_BUFFER;
		}
	}


	if (LC_SUCCESS == result)
	{        

		/* parse */
		LC_memcpy(pMsgParsed->loaderRealInfoControl, &pabMsg[0], SIZE_LODER_INFO_CONTROL);
		LC_memcpy(pMsgParsed->loaderUpgradeInfoControl, &pabMsg[SIZE_LODER_INFO_CONTROL],SIZE_LODER_INFO_CONTROL);
		LC_memcpy(pMsgParsed->loaderReservedInfoControl, &pabMsg[SIZE_LODER_INFO_CONTROL*2], SIZE_LODER_RESERVED_INFO_CONTROL);
		LC_memcpy(pMsgParsed->loaderPubKey, &pabMsg[SIZE_LODER_INFO_CONTROL*2 + SIZE_LODER_RESERVED_INFO_CONTROL], SIZE_PUBKEY);
		LC_memcpy(pMsgParsed->loaderPubKeyAuthMsg, &pabMsg[SIZE_LODER_INFO_CONTROL*2 + SIZE_LODER_RESERVED_INFO_CONTROL + SIZE_PUBKEY], SIZE_PUBKEY);


		/* check if UK information corrupted */
		result = UkCheckValid(pMsgParsed);

		if (LC_SUCCESS == result)
		{
			/* if pointer of Authentication result not equals NULL, copy them back */
			if (LC_NULL != pabAuthed )
			{
				LC_memcpy(pabAuthed, pMsgParsed, sizeof(lc_key_update_message));
			}

		}
	}

	LC_Free_Memory((void **)&pMsgParsed);

    return result;


} /* DecryptUK */




lc_result LC_AuthenticateUK (const lc_uchar* pabMsg, lc_uint32 wMsgLen, lc_bool *pIsAManKey)
{

    lc_uint32 errCode = ERROR_CODE_SUCCESS;
    lc_result result = LC_SUCCESS;
    lc_key_update_message *pMsgUkDecrypted = LC_NULL;
    lc_key_update_message *pExistingUkClear = LC_NULL;
    /* system ID and key version (to be updated) retrieved from module */
    lc_uint16 sysIdNow = 0; 
    lc_uint16 keyVerNow = 0;
    /* system ID and key version (for authentication use only) retrieved from Message */
    lc_uint16 sysIdMsgClear = 0; 
    lc_uint16 keyVerMsgClear = 0;
    /* system ID and key version (to be updated) retrieved from Message */
    lc_uint16 sysIdMsgFull = 0; 
    lc_uint16 keyVerMsgFull = 0;
    /* minimum new version and maximum increment acceptable for update */
    lc_uint16 minVer = 0;
    lc_uint16 maxInc = 0;
    

	if (wMsgLen < SIZE_UK_DATA)
	{
		result = LC_FAILURE;
		errCode = ERROR_CODE_DL_KEY_CORRUPTED;
	}

    /* Try to get and decrypt existing UK. */
    if (LC_SUCCESS == result)
    {
        pExistingUkClear = LC_MALLOC(sizeof(lc_key_update_message));
        if (LC_NULL == pExistingUkClear)
        {
            result = LC_ERROR_INSUFFICIENT_BUFFER;
        }
    }
    
    if (LC_SUCCESS == result)
    {
        result = LC_GetClearKeyData(pExistingUkClear);
    }

    
    /* Set parameters for authentication */
    
    /* If UK module exists and has been decrypted. Get system ID and key version from 
     * abFullControl field for authentication. */
    if (LC_SUCCESS == result)   
    {
		sysIdNow = LC_GetUint16(pExistingUkClear->loaderRealInfoControl, 0);
		keyVerNow = LC_GetUint16(pExistingUkClear->loaderRealInfoControl, 2);
        minVer = keyVerNow + 1; /* Key version must at least increase 1. */
        maxInc = DEFAULT_MAX_INCREMENT_FOR_KEY_VERSION;
    }
    /* If UK module does not exist(e.g., a virgin device) or has been corrupted, we assume this device  
     * is a virgin one, and set parameters to default so that this device can only update Manufacturer Key. */
    else
    {
        /* The device shall assume system ID = 0xffff if UK not exists */
        sysIdNow = 0xFFFF;
        minVer = 0;
        maxInc = 1;                    /* Only one key version is acceptable */

        /* Not an error in this case. */
        result = LC_SUCCESS;
    }

    LC_Free_Memory((void **)&pExistingUkClear);

    /* Do authentication on UK. */

    /* Step 1: System ID and "key sequence number" */
    if (LC_SUCCESS == result)
    {

        if (LC_SUCCESS == result)
        {
            /* check if UK should be updated */
			sysIdMsgClear = LC_GetUint16(pabMsg, SIZE_LODER_INFO_CONTROL);
			keyVerMsgClear = LC_GetUint16(pabMsg, SIZE_LODER_INFO_CONTROL + 2);
        }
        
        /* Check System ID, the System ID derived from Clear Field must be equal to that of the current key */
        if (LC_SUCCESS == result)
        {
            if (sysIdNow != sysIdMsgClear)
            {
                result = LC_ERROR_INVALID_KEY;
                errCode = ERROR_CODE_DL_KEY_INCORRECT_SYS_ID;
            }
        }

        /* Check "key version "? */
        if (LC_SUCCESS == result)
        {
            if (((keyVerMsgClear - minVer) & 0xFFFF) > maxInc)
            {
                result = LC_ERROR_INVALID_KEY;
                errCode = ERROR_CODE_DL_KEY_INCORRECT_KEY_VER;
            }
        }
    }

    /* Step 2: and Key version match? */
    if (LC_SUCCESS == result)
    {
        pMsgUkDecrypted = LC_MALLOC(sizeof(lc_key_update_message));
        if (LC_NULL == pMsgUkDecrypted)
        {
            result = LC_ERROR_INSUFFICIENT_BUFFER;
        }
        
        /* Check if UK information distorted */
        if (LC_SUCCESS == result)
        {  
            result = DecryptUK(pMsgUkDecrypted, pabMsg, wMsgLen);  
            if (LC_SUCCESS != result)
            {
                errCode = ERROR_CODE_DL_KEY_CORRUPTED;
            }
        }

        if (LC_SUCCESS == result)
        {
            /* Authentication OK */
			sysIdMsgFull = LC_GetUint16(pMsgUkDecrypted->loaderRealInfoControl, 0);
			keyVerMsgFull = LC_GetUint16(pMsgUkDecrypted->loaderRealInfoControl, 2);

            /* Some Type Key update(e.g, DEV-KEY -> DEV-KEY), ought to check key version. */
            if (sysIdMsgFull == sysIdNow)
            {
                if ( (keyVerMsgFull <= keyVerNow) || 
                   (((keyVerMsgFull - keyVerNow) & 0xFFFF) > maxInc) )
                {
                    result = LC_ERROR_INVALID_KEY;
                    errCode = ERROR_CODE_DL_KEY_OLD_KEY_VER;
                }

            }
                             
        }

        LC_Free_Memory((void **)&pMsgUkDecrypted);
    }

    /* Is it a Manufacturer Key? */
    if (LC_SUCCESS == result)
    {
        *pIsAManKey = (SYS_ID_MANKEY == sysIdMsgFull)? LC_TRUE : LC_FALSE;
    }

    /* Report Errorcode */
    ERR_REPORT_SetErrorCode(errCode);
    
    return result;

}

lc_result LC_RetrieveUK(lc_uchar** ppUkData, lc_uint32* pUkLength)
{
    lc_result result = LC_SUCCESS;
    lc_uint32 errCode = ERROR_CODE_SUCCESS;
    lc_buffer_st mp_uk = {LC_NULL, 0};
    lc_uchar* pAuthKey = LC_NULL;
    lc_key_update_message *pMsgParsed = LC_NULL;

    if (LC_NULL == ppUkData)
    {
        result = LC_ERROR_NULL_PARAM;
    }

    if (LC_SUCCESS == result)
    {
        pMsgParsed = LC_MALLOC(sizeof(lc_key_update_message));
        if (LC_NULL == pMsgParsed)
        {
            result = LC_ERROR_INSUFFICIENT_BUFFER;
        }
    }

    /* read UK from UK module */
    if (LC_SUCCESS == result)
    {
        result = LC_GetClearKeyData(pMsgParsed);
        if (LC_SUCCESS != result)
        {
            errCode = ERROR_CODE_RESIDENT_KEY_INVALID;
        }
    }
    
    if (LC_SUCCESS == result)
    {      
        if (LC_SUCCESS == result)
        {            
			pAuthKey = (lc_uchar*)LC_MALLOC(SIZE_PUBKEY);
            if (LC_NULL == pAuthKey)
            {
                result = LC_ERROR_INSUFFICIENT_BUFFER;
            }
        }

        /* return UK data and length */
        if (LC_SUCCESS == result)
        {
            /* copy authenticated key to user pointer */ 
			LC_memset(pAuthKey, 0, SIZE_PUBKEY);                   /* clear output buffer */
			LC_memcpy(pAuthKey, pMsgParsed->loaderPubKey, SIZE_PUBKEY); /* write UK pub */
            *ppUkData = pAuthKey;

            /* return authenticated key length */
            if (LC_NULL != pUkLength)
            {
                *pUkLength = SIZE_PUBKEY;
            }                  
        }
    }

    LC_Free_Memory((void **)&pMsgParsed);
    LC_Free_Memory((void **)&mp_uk.bytes);

    /* Report Errorcode */
    ERR_REPORT_SetErrorCode(errCode);

    return result;
	
}

lc_result LC_CheckMasterKey(void)
{
    lc_result result = LC_SUCCESS;
	lc_uchar pubKey[SIZE_PUBKEY] = {0};
	lc_uchar mskData[SIZE_PUBKEY] = {0};
	lc_buffer_st pMessage = {LC_NULL, 0};
	lc_uchar mskAuthMsg[SIZE_PUBKEY] = {0};

	LC_memcpy(pubKey, abMasterKey, SIZE_PUBKEY);
	LC_memcpy(mskData, abMasterKey, SIZE_PUBKEY);
	LC_memcpy(mskAuthMsg, abMasterKey + SIZE_PUBKEY, SIZE_PUBKEY);

	pMessage.bytes = mskData;
	pMessage.length = SIZE_PUBKEY;

	if (LC_TRUE != CheckKeyMsg(pubKey, &pMessage, mskAuthMsg))
	{
		result = LC_ERROR_INVALID_KEY;
	}
    return result;
	
}

lc_result LC_GetClearKeyData (lc_key_update_message* pClearKeyData)
{
 
	lc_result result = LC_SUCCESS;
    lc_uint32 errCode = ERROR_CODE_SUCCESS;
    lc_buffer_st mp_uk = {LC_NULL, 0};
    

    /* check & read UK from UK module */
    if( LC_SUCCESS == result )
    {
        lc_bbcb_st bbcb;
        result = BBCB_GetBBCB(&bbcb, LC_NULL);
        if( LC_SUCCESS != result)
        {
            errCode = ERROR_CODE_INVALID_BBCB;
            TRACE_LOG0(TRACE_ERROR, ("&[KeyUpdate] Error: Failed to retrieve BBCB!\n"));
        }
        else
        {
            result = LC_ReadAndVerifyExistingModule(
                                MODULE_DRV_ID_UK, 
                                LC_FALSE, 
                                bbcb.boot_check_algorithm,
                                LC_NULL, 
                                LC_NULL,
                                LC_NULL,
                                &mp_uk );
        }
    }
    
    if (LC_SUCCESS == result)
    {      
        /* decrypt UK and replace it with the clear one */
        result = DecryptUK( pClearKeyData, mp_uk.bytes, mp_uk.length);
        if (LC_SUCCESS != result)
        {
            errCode = ERROR_CODE_RESIDENT_KEY_CORRUPT;
        }
    }

    LC_Free_Memory((void **)&mp_uk.bytes);

    /* Report Errorcode */
    ERR_REPORT_SetErrorCode(errCode);

    return result;

}


